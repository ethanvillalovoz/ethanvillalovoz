<!--
CS 6515 – Intro to Graduate Algorithms

CS 7641 – Machine Learning

CS 6476 – Computer Vision

CS 7650 – Natural Language Processing

CS 7638 – AI Techniques for Robotics

CS 7637 – Knowledge-Based AI

CS 7642 – Reinforcement Learning

CS 7643 – Deep Learning

ISYE 6420 – Bayesian Statistics

CS 8803 O21: GPU Hardware and Software

---
-->
<!-- Typing Animation Banner (WSU Crimson, fixed size) -->
<!--
<p align="center">
  <img src="https://readme-typing-svg.demolab.com?font=Fira+Code&weight=500&pause=1000&color=9D2235&center=true&multiline=true&height=100&width=600&lines=Hey+there+%F0%9F%91%8B+I'm+Ethan+Villalovoz;CS+Grad+%7C+AI%2FML+Researcher+%26+Engineer;Always+down+to+collab+or+chat!" />
</p>
-->

<!-- Static Title Banner (optional custom image) -->
<!-- If capsule-render fails again, replace this with your own uploaded image -->
<p align="center">
  <img src="https://capsule-render.vercel.app/api?type=waving&color=9D2235&height=180&section=header&text=Welcome%20to%20My%20GitHub!&fontSize=38&fontAlign=50&fontColor=f3f3f3" />
</p>

---

### 👨‍💻 About Me

I'm **Ethan** — a builder and researcher passionate about **human-centered AI** and robotics.

- 🎓 B.S. in Computer Science from **Washington State University**
- 🧪 Research at **CMU**, Oregon State, and WSU (focus: RLHF, robotics, multimodal learning)
- 💼 Former **Google STEP intern** — built internal devtools in C++ and SQL
- 🧠 Excited about: **LLMs**, **robot learning**, **clarification systems**, **RL**, and **AI policy**

<!-- 🔧 I built [ClarifyBot](https://github.com/ethanvillalovoz/clarifybot) — a robot that asks follow-up questions when human feedback is ambiguous. -->

---

### 🧰 Languages & Tools

<p align="center">
  <img src="https://skillicons.dev/icons?i=python,cpp,html,css,latex,haskell,matlab,r&theme=dark" />
</p>
<p align="center">
  <img src="https://skillicons.dev/icons?i=pytorch,tensorflow,git,docker,linux,vscode,visualstudio,pycharm&theme=dark" />
</p>

---
<!--
### 🚀 Featured Projects

| 🧠 Project | 📝 Description | ⚙️ Tech |
|-----------|----------------|--------|
| [ACME10-HE-RAGApp](https://github.com/mollyiverson/ACME10-HE-RAGApp) | RAG-based chatbot with vector search and DBpedia knowledge graphs | FAISS, OpenAI, FastAPI |

---
-->
### 📊 Stats

<div align="center">
  <img height="180" src="https://github-readme-stats.vercel.app/api/top-langs/?username=ethanvillalovoz&layout=compact&theme=dark&title_color=9D2235&text_color=f3f3f3&bg_color=10151a&border_radius=10&hide_border=false&cache_seconds=1800" alt="Top Languages" />

  <img height="180" src="https://github-readme-stats.vercel.app/api?username=ethanvillalovoz&count_private=true&show_icons=true&theme=dark&title_color=9D2235&icon_color=C94F5C&text_color=f3f3f3&bg_color=10151a&hide_border=false&rank_icon=github&border_radius=10" alt="GitHub Stats" />
</div>

<br/>

<div align="center">
  <img width="440" src="https://github-readme-streak-stats.herokuapp.com/?user=ethanvillalovoz&count_private=true&theme=dark&ring=9D2235&currStreakLabel=C94F5C&background=10151a&hide_border=false&border_radius=10&card_width=495" alt="GitHub Streak" />
</div>

---

### 🧠 Currently...
- 📝 Applying to full-time AI/ML research roles
- 🎯 Preparing for MS applications (Spring 2026)

Thanks for visiting — feel free to reach out if you want to chat or collaborate!

<!--
How can i make this code more modularized and aligning with best code practices:
1. Separate Classes into Different Files
2. Use Configurations
Use a config file (YAML, JSON, or Python dict) for hyperparameters instead of hardcoding them in main.py.
3. Add Docstrings and Type Hints
Add docstrings and type hints to all functions and classes for clarity and maintainability.
4. Logging Instead of Print
Use Python’s logging module instead of print for better control over output.
5. Model Saving/Loading Paths
Allow model save/load paths to be passed as arguments.
6. Environment Wrapping
Consider wrapping the environment for normalization, seeding, etc.
8. Add Unit Tests
Create a tests/ directory and add unit tests for each module.
9. PEP8 Formatting
Ensure code follows PEP8 style guidelines (indentation, naming, etc.).
Example command:
To auto-format your code with black:

To check for issues with flake8:
------------------------------------------------------------------------------------------------------------------------
What each readme project should have

Section

Tips

Badges

Also known as shields. Highlight information about the project, for example downloads or build status

Introduction

Keep this short about the goal of the project

Description

Go into more details about the project

Visuals

This will really help your README and project standout, use screenshots or animated gifs

Prerequisites / requirements

What the user is required to have already installed, for example Docker

Technologies used in the project

Projects usually use a lot of libraries and frameworks, an exhaustive list is not required. However, it is useful to list the main technologies, for example React with TailwindCSS

QuickStart guide

How people can get started with the basics, this needs to be straight forward and the path for least resistance

Advanced usage

How people can do more with your project

Configuration

This can be from private keys and tokens to customizing the project

Automated test

This will give confidence that the project is working locally with the relevant dependencies

Roadmap

What features are coming up, this can be a list or table, but also have a look at Github Project boards (GitHub themselves use this for their roadmap)

Contribution

GitHub does allow for a specific CONTRIBUTORS.md file, however a brief overview in the README could be useful
------------------------------------------------------------------------------------------------------------------------
-->

<!--
------------------------------------------------------------------------------------------------------------------------
Folder Structure:

Most projects have a similar based folder structure of:

src/

tests/

.gitignore

LICENSE

README.md

...
------------------------------------------------------------------------------------------------------------------------
-->

<!--
------------------------------------------------------------------------------------------------------------------------
Documanetation advice:

The README should include:

What the project goals are

What does it look like

What are the prerequisites that are required (for example node v12+)

As the README grows, it is recommended to use the docs/ folder to have it separated into sections.

The README is best used to focus on the immediate value ideas, for example:‌

Prerequisite: what is needed to be installed first; for example node v12+

Quickstart: how people can get started with the basics; for example running the automated tests

Configuration / environment variables: what configuration is needed; for example database credentials

Directory structure: what files are where and why; for example artifacts

Deployment: what branches deploy to which environment; for example main to production

FAQ / troubleshooting: what common issues do people have and what solutions work

3.1. Types

There are multiple types of documentation, from inline comments to technical documentation and user documentation. Each has a dedicated goal aimed at a particular consumer.

Types of documentation could include:

Type

Goal

Example

Architecture

Broad technical requirements

Database design, multiple systems integration

End user guide

Walk user through how to navigate and use the application

How to register, how to delete their account

Product

High level of what the system should do

Banking application that allows people to pay

Technical

How to run / use the tool

Deploying the application

3.2. Diagrams

Annotated screenshots and diagrams can help explain workflow and architecture more effectively. 

There are specific tools to draw diagrams, for example Google Draw, Adobe Illustrator, however these are not recommended. 

When someone else needs to update the diagram, they are unlikely to have access to the original source file or have the correct program installed. Also, when reviewing a diagram which is a binary file, it is very difficult to notice the changes that were made. 

This challenge can be reduced by using SVG files which can be opened by various applications, however it is not seamless.

When possible it is better to use tools like Mermaid which allows diagrams to be drawn using markup style code.‌

Currently supported diagrams are:

Flowchart

Sequence diagram

Class diagram

State diagram

Entity Relationship diagram

User journey

Gantt

Pie chart

Sequence diagram example using Mermai

Below is the code for the sequence diagram above. Both should be included in the documentation project, making it easier for people to make changes and even easier when it is being reviewed to see what has changed, just like with code.

3.3. Contributors file

Having a CONTRIBUTING.md file helps the maintainer communicate how to get involved in the project, and helps the contributor know how to add value. This improves the communication and helps focus it on the more useful collaborations.

This special file can be located in one of three places:

/ folder

docs/ folder

.github folder

Then GitHub uses this file in one of those locations to present to the user when they either create an issue or pull request.

CONTRIBUTORS.md link when creating an issue


CONTRIBUTORS.md link when creating an issue


What to include
How to create a good issue or pull request

Useful links from internal to external documentation, mailing lists, code of conduct etc

Other community rules and expectations

Examples
Atom editor

Ruby on Rails

Open government

3.4. Issue template

When issues are created, they are rarely consistent and often do not include important and relevant information. However this can be improved by creating templates for the usual issue types. These types could include:

Bug / defect

Feature / story

Idea / feature request

To add an issue template to the project, create a file in .github/ISSUE_TEMPLATE/<name>.md. There is no limit in the amount of template types, style or content, however some meta data is recommended.

Here is an example of a simple bug template, that adds a label and assigns it to a user (both are optional and can be omitted).


---

name: Bug

about: 'Bug / defect template'

title: 'I found a bug ...'

labels: bug

assignees: 'MLH'

---

## Steps to reproduce

```gherkin

Given ...

When ...

Then ...

---

## Expected result
gherkin

Given ...

When ...

Then ...

---

## Technical
| Tech | Details |

| :--- | :--- |

| Browser | safari / firefox / chrome |

| Version | v12 |

| Operating system | OSx / Windows / Linux |

Screenshots

When creating a new issue, the user is presented with available template options:

3.5. PR Template
 
When a PR is created, if a template file exists, it will automatically be populated to make it easier for the author to fill in the information about the PR.

The template could include:

Issue number

Tasks

Screenshots

To create a template, add the file .github/PULL_REQUEST_TEMPLATE.md with the content for the template. 

closes #ISSUE-NO

Please include a summary of the change and which issue it solves.

Also include relevant motivation and context.

List any dependencies that are required for this change.

## Tasks

- [ ]task 1

- [ ]task 2

- [ ] ...

## Screenshots (if appropriate)

PRs can close their respective issues by mentioning closes #123 and this also puts a reference in the issue timeline back to the PR.

Issue timeline with reference back to the PR

Issue timeline with reference back to the PR
------------------------------------------------------------------------------------------------------------------------
-->

<!--
------------------------------------------------------------------------------------------------------------------------
Architecture
SOLID principles improve project maintainability by decoupling, reducing duplication and encouraging re-use.

Principle

Abbreviation

Description

Single Responsibility Principle

SRP

Class should only have one job

Open / Closed Principle

OCP

Classes should be open for extension and closed for modification 

Liskov substitution principle

LSP

Every concrete class should be substitutable for their parent class

Interface segregation principle

ISP

Interfaces should be specific and not general

Dependency Inversion Principle

DIP

Depend on abstractions rather than concrete classes
------------------------------------------------------------------------------------------------------------------------
-->

<!--
------------------------------------------------------------------------------------------------------------------------
3. Video Structure

Think of things to entice the viewer and keep them engaged. The first 30 seconds must capture the audience, bring them into your story and along your journey.

Things to include
Challenge / objective

What problem are you trying to solve with your project

How did your project solve this

Why is your solution unique or better than existing solutions

Demo

Show the best and most interesting parts of your project

Include any challenges and (possible) solutions

What technologies did you use and why

What is the project dream and future features / goals

Conclusion

Re-cap the problem

Explain why your project solves this well


Do not include
Opening remarks such as

Thanking the organizers / mentors / venue

Thanking your team

How much you didn't sleep because of this project

Waste time editing with fancy animations or effects
------------------------------------------------------------------------------------------------------------------------
-->
